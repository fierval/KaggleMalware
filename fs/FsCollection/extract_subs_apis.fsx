open System
open System.IO
open System.Linq
open System
open System.Collections.Generic

#load "utils.fsx"
open Utils

let inPath = @"h:\kaggle\malware\text\test"
let lbpPath = @"c:\kaggle\malware\test\1dlbp"
let outPath = @"c:\kaggle\malware\test\mix_lbp_counts"
let featureDic = @"c:\kaggle\malware\apiDict.csv"
createOutputDir outPath

let files = Directory.GetFiles(inPath, "*.asm")
let lbpFiles = Directory.GetFiles(lbpPath, "*.lbp")
let strippedFiles = HashSet(lbpFiles.Select(fun f -> defile f))
let listOfApis = File.ReadAllLines(featureDic).Select(fun s -> s.Trim()).ToList()
listOfApis.Sort()
let apiSet = HashSet<string>(listOfApis)

let countOnly = true

let countOccurs (str : string) (arr : List<string>) =
    arr.AsParallel().Count(fun a -> a.IndexOf(str) >= 0)

// take each file and parse it. Create a dictionary
for file in files do
    if strippedFiles.Contains(defile file) then
        let lines = File.ReadLines(file).SkipWhile(fun l -> not (l.StartsWith ".text")).TakeWhile(fun l -> l.StartsWith(".text")).ToList()

        let feats = File.ReadLines(file).SkipWhile(fun l -> not (l.StartsWith ".idata")).TakeWhile(fun l -> l.StartsWith(".idata")).ToList()

        let lbp = Path.Combine(lbpPath, Path.ChangeExtension(defile file, ".lbp"))
        let bytes = (File.ReadAllBytes lbp).ToList()

        // extract APIs
        let  features = Dictionary<string, int>()
        let mutable subrs = 0

        for line in feats do

            let meanIndex = line.IndexOf("extrn")
            if meanIndex >= 0 then
                let apis = line.Substring(meanIndex + "extrn".Length).Trim().Split([|' '; ':'; '_';'@';',';'(';')';'?';'0'|])
                let maxLen = apis.Where(fun x -> x.Length > 0 && Char.IsLetter(x.[0])).Max(fun x -> x.Length)
                let api = apis.First(fun x -> x.Length = maxLen)

                if apiSet.Contains(api) then
                    let n = countOccurs api lines
                    if features.ContainsKey api then
                        features.[api] <- features.[api] + n
                    else
                        features.[api] <- n
    
        // extract subroutines
        for line in lines do
            let meanIndex = line.IndexOf("  ")
            if meanIndex > 0 then
                let meanLine = line.Substring(meanIndex).Trim(' ')

                if (not (String.IsNullOrWhiteSpace(meanLine))) then
                    if meanLine.IndexOf("S U B R O U T I N E") > 0 then
                        subrs <- subrs + 1
            
        (BitConverter.GetBytes subrs).ToList().ForEach(fun b -> bytes.Add b)
    
        let missing = apiSet.Except(features.Keys)
        let missingDict = missing.ToDictionary((fun x -> x), (fun x -> 0))
//            let final = features.Concat(missingDict).OrderBy(fun kvp -> kvp.Key).Select(fun kvp -> if not countOnly then kvp.Key + "," + kvp.Value.ToString() else kvp.Value.ToString()).ToArray()
            
        let final = features.Concat(missingDict).OrderBy(fun kvp -> kvp.Key).Select(fun kvp -> kvp.Value).ToList()
        final.SelectMany(fun i -> BitConverter.GetBytes(i).AsEnumerable()).ToList().ForEach(fun b -> bytes.Add b)

        saveFile (bytes.ToArray()) outPath file ".lbp"
    printfn "Processed: %s" (Path.GetFileName file)            

