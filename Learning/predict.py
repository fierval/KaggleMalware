from tr_utils import write_to_csv, time_now_str, vote_reduce, vote
from SupervisedLearning import SKSupervisedLearning
from train_files import TrainFiles
from sklearn.ensemble import RandomForestClassifier, ExtraTreesClassifier
from sklearn.svm import SVC
from os import path
from sklearn.metrics import log_loss
from sklearn.decomposition.pca import PCA

prediction = True
doTrees = True

tf = TrainFiles('/kaggle/malware/train/mix_lbp_200', '/kaggle/malware/test/mix_lbp_200', "/kaggle/malware/trainLabels.csv", validate = not prediction)

X_train, Y_train, X_test, Y_test = tf.prepare_inputs()

def predict(X_train, Y_train, X_test):
    # no validation labels on actual prediction
    if doTrees:
    
        # random forest
        sl_rfc = SKSupervisedLearning(RandomForestClassifier, X_train, Y_train, X_test, Y_test)
        sl_rfc.fit_standard_scaler()
        sl_rfc.train_params = {'max_depth': 100, 'n_estimators': 8000}

        print "Starting on RF: ", time_now_str()

        _, ll_rfc = sl_rfc.fit_and_validate()
        print "RF score: {0:.4f}".format(ll_rfc if not prediction else _)

    sl_svm = SKSupervisedLearning(SVC, X_train, Y_train, X_test, Y_test)
    sl_svm.fit_standard_scaler()
    sl_svm.train_params = {'C': 100, 'gamma': 0.001, 'probability': True}

    print "Starting SVM: ", time_now_str()
    _, ll_svm = sl_svm.fit_and_validate()

    print "SVM score: {0:.4f}".format(ll_svm if not prediction else _)
    print "Finished training: ", time_now_str()

    if prediction:
        proba = vote_reduce([sl_svm.proba_test, sl_trees.proba_test], [2./3., 1./3.])
        #proba = sl_svm.proba_test

        out_labels = "/kaggle/malware/submission22.csv"
        task_labels = "/kaggle/malware/testLabels.csv"
        labels = [path.splitext(t)[0] for t in tf.get_val_inputs()]
        write_to_csv(task_labels, labels, proba, out_labels)

    else:
        # visualize the decision surface, projected down to the first
        # two principal components of the dataset
        pca = PCA(n_components=2).fit(sl_svm.X_train_scaled)

        X = pca.transform(sl_svm.X_train_scaled)

        x = np.arange(X[:, 0].min() - 1, X[:, 1].max() + 1, 1)
        y = np.arange(X[:, 1].min() - 1, X[:, 1].max() + 1, 1)

        xx, yy = np.meshgrid(x, y)

        # title for the plots
        titles = ['SVC with rbf kernel',
                  'Random Forest \n'
                  'n_components=7500',
                  'Decision Tres \n'
                  'n_components=7500']

        #plt.tight_layout()
        plt.figure(figsize=(12, 5))

        # predict and plot
        for i, clf in enumerate((sl_svm.clf, sl_rfc.clf, sl_trees.clf)):
            # Plot the decision boundary. For that, we will assign a color to each
            # point in the mesh [x_min, m_max]x[y_min, y_max].
            plt.subplot(1, 3, i + 1)
            clf.fit(X, Y_train)
            Z = clf.predict(np.c_[xx.ravel(), yy.ravel()])

            # Put the result into a color plot
            Z = Z.reshape(xx.shape)
            plt.contourf(xx, yy, Z, cmap=plt.cm.Paired)
            plt.axis('off')

            # Plot also the training points
            plt.scatter(X[:, 0], X[:, 1], c=Y_train, cmap=plt.cm.Paired)

            plt.title(titles[i])
        plt.tight_layout()
        plt.show()
