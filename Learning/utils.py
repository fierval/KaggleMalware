import numpy as np
from time import gmtime, strftime, localtime
import csv

def append_to_arr(arr, a, axis = 0):
    '''
    Append a to a numpy array arr. a - scalar, list or numpy array
    '''
    if isinstance(a, list) or isinstance(a, np.ndarray):
        a = np.array(a)

        if arr.shape[0] == 0:
            arr = a.reshape(1, a.shape[0])
        else:
            arr = np.append(arr, a.reshape(1, a.shape[0]), axis = axis)
    else:
        if arr.size == 0:
            arr = np.array([a]) # make sure it is a 1-dimensional array
        else:
            arr = np.append(arr, a)
    return arr

def time_now_str():
    return strftime("%d %b %Y %H:%M:%S", localtime())

def merge_two_dicts(x, y):
    '''Given two dicts, merge them into a new dict.
    '''
    z = x.copy()
    z.update(y)
    return z

def vote(proba_list, weight_list):
    '''
    Given a list of probability arrays and a list of weights,
    Compute the final array by summiing probabilities and multiplying by their weights
    '''
    wts = np.array(weight_list)
    if wts[wts == 1].shape[0] == wts.shape[0]:
        proba = np.array([x for x in proba_list])
        return proba.mean(0)
    else:
        proba = np.array([x[0] * x[1] for x in zip(proba_list, weight_list)])
        return proba.sum(0)
     
def vote_reduce(ar1, ar2, weights = []):
    '''
    Given two arrays and a list of two weights, apply the voting rule as in vote(), unless
    a 0 is encountered. In which case pick the unweighted non-zero element.
    If no weights are specified, they are assumed to be 1/2 each
    '''
    res = np.array([])
    func = lambda x, y: (x + y) / 2. if len(weights) == 0 else x * weights[0] + y * weights[1]

    for i in range(0, ar1.shape[0]):
        pr1 = ar1[i]
        pr2 = ar2[i]
        cur_proba = [ func(pr1[j], pr2[j]) if pr2[j] != 0 else ( pr2[j] if pr1[j] == 0 else pr1[j]) \
            for j in range(0, ar1.shape[1])]
        res = append_to_arr(res, cur_proba)    
    return res

def write_to_csv(task_labels, labels, proba, out_labels):
    with open (task_labels, "rb") as readlabels:
        reader = csv.reader(readlabels)
        first = True
        for row in reader:
            if first:
                res = [row]
                first = False
            else:
                l = [row[0]]
                l.extend(map(lambda x: float(x), row[1:]))
                res.append(l)
    
    for i in range(0, len(labels)):
        l = [labels[i]]
        l.extend(proba[i])
        res.append(l)

    with open(out_labels, "wb") as outlabels:
        writer = csv.writer(outlabels, quoting = csv.QUOTE_NONNUMERIC)
        for row in res:
            writer.writerow(row)
            
    return res

def isEmpty(arr):
    return len(arr) == 0