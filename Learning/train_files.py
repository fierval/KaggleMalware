import os
from os import path
import numpy as np
import csv
import shutil
import sys

from utils import append_to_arr

class TrainFiles(object):
    """
    Utilities for dealing with the file system
    """
    def __init__(self, train_path = None, val_path = None, labels_file = None, debug = True):
        self.train_path = train_path
        self.val_path = val_path
        self.labels_file = labels_file
        self._cutoff = sys.maxint
        self._floor = 0
        self.labels = None
        self.debug = debug

    def __str__(self):
        return 'train: {0}, validate: {1}, labels: {2}'.format(self.train_path, self.val_path, self.labels_file)

    @property
    def cutoff(self):
        """
        Max file size to consider when listing directory content
        """
        return self._cutoff

    @cutoff.setter
    def cutoff(self, val):
        self._cutoff = val

    @property
    def floor(self):
        return self._floor

    @floor.setter
    def floor(self, val):
        self._floor = val

    def get_size(self, file, dir) :
        return os.stat(path.join(dir, file)).st_size

    def _get_inputs(self, dir):
        return filter (lambda x: not path.isdir(path.join(dir, x)) and self.get_size(x, dir) > self.floor and self.get_size(x, dir) <= self.cutoff, os.listdir(dir))

    def get_training_inputs(self):
        """
        retrieves file names (not full path) of files containing training "image" data
        """
        return self._get_inputs(self.train_path)

    def get_val_inputs(self):
        """
        retrieves file names (not full path) of files containing training "image" data
        """
        return self._get_inputs(self.val_path)

    def get_labels_csv(self):
        """
        retrieves the values of each class labels assuming they are stored as the following CSV:
        
        | ID | Class |

        """
        with open(self.labels_file, 'rb') as csvlabels:
            lablesreader = csv.reader(csvlabels)
            file_label = map(lambda x: (x[0], int(x[1])), [(row[0], row[1]) for row in lablesreader][1:])
        return file_label
    
    def _connect_labeled_data(self, inp_path, inputs):
        if self.labels == None:
            self.labels = self.get_labels_csv()

        X = np.array([])
        Y = np.array([])
        for inp in inputs:
            inp_file = path.join(inp_path, inp)
            label_name = path.splitext(inp)[0]
            x = np.fromfile(inp_file, dtype='int')
            x = x.astype('float')
            label = filter(lambda x: x[0] == label_name, self.labels)[0][1]
            X = append_to_arr(X, x)
            Y = np.append(Y, label)
            if self.debug:
                print "Processed: " + inp_file
        return X, Y

    def connect_labeled_data(self, training = True):
        """
        Read the training/validation file names and produce two arrays, which once zipped
        and iterated over will form a tuple (itemI, classI)
        """
        inputs = self.get_training_inputs() if training else self.get_val_inputs()
        inp_path = self.train_path if training else self.val_path
        return self._connect_labeled_data(inp_path, inputs)